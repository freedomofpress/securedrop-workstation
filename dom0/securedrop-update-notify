#!/usr/bin/env python3

"""
Displays a warning to the user if the workstation has been running continuously
for too long without checking for security updates
"""

from datetime import datetime
import fcntl
import logging
import os
import subprocess
import sys
from PyQt4 import QtGui
from PyQt4.QtGui import QMessageBox

sdlog = logging.getLogger(__name__)

# This will create a lock file in /run, which is a temporary filesystem that
# does not persist upon reboots
LOCK_FILE = "/run/lock/securedrop-update-notify.lock"
UPDATER_LOCK_FILE = "/run/lock/sdw-launcher.lock"
WARNING_THRESHOLD = 432000  # 5 days (specified in seconds)
UPTIME_GRACE_PERIOD = 1800  # 30 minutes (specified in seconds)

lock_handle = ''  # Global handle to hold on to exclusive lock during execution
last_updated_file = ''  # Location of timestamp file, dependent on GUI user name
last_updated_file_exists = ''  # Convenience global


def main():
    obtain_updater_lock()
    obtain_notify_lock()
    locate_last_updated_file()
    run_checks()


def obtain_updater_lock():
    # We do not need to hold on to this lock, as we only want to verify if
    # the updater is already running

    # TODO: Exception handling
    lh = open(UPDATER_LOCK_FILE, 'r')
    try:
        # Obtain a nonblocking, shared lock
        fcntl.lockf(lh, fcntl.LOCK_SH | fcntl.LOCK_NB)
    except IOError:
        sdlog.error("Error obtaining lock on {}\n"
                    "Preflight updater may already be running. Exiting."
                    .format(LOCK_FILE))
        sys.exit(1)


def obtain_notify_lock():
    global lock_handle
    # TODO: Exception handling
    lock_handle = open(LOCK_FILE, 'w')
    try:
        # Obtain an exclusive, nonblocking lock
        fcntl.lockf(lock_handle, fcntl.LOCK_EX | fcntl.LOCK_NB)
    except IOError:
        sdlog.error("Error obtaining lock on {}\n"
                    "Notification may already be displaying. Exiting."
                    .format(LOCK_FILE))
        sys.exit(1)


def locate_last_updated_file():
    global last_updated_file, last_updated_file_exists
    gui_user = get_gui_user()
    last_updated_file = os.path.join(os.path.expanduser("~" + gui_user),
                                     ".securedrop_launcher/sdw-last-updated")
    last_updated_file_exists = os.path.exists(last_updated_file)


def run_checks():
    # Get timestamp from last update (if it exists)
    # TODO: Exception handling
    if last_updated_file_exists:
        with open(last_updated_file, 'r') as f:
            last_update_time = f.readline().splitlines()[0]
            last_update_time = datetime.strptime(last_update_time, "%Y-%m-%d %H:%M:%S")
            now = datetime.now()
            updated_seconds_ago = (now - last_update_time).total_seconds()
            updated_hours_ago = updated_seconds_ago / 60 / 60

    # Obtain current uptime
    with open('/proc/uptime', 'r') as f:
        uptime_seconds = float(f.readline().split()[0])
        uptime_hours = uptime_seconds / 60 / 60

    # If we do not have the timestamp file, and the system has been running for
    # a long time, we should show the warning.
    if not last_updated_file_exists and uptime_seconds > WARNING_THRESHOLD:
        sdlog.warning("The SecureDrop Workstation has been running for {0:.1f} "
                      "hours without checking for updates. Showing security warning."
                      .format(updated_hours_ago))
        show_update_notification()

    # If the last successful update has been a long time ago, and we have not just
    # started the system, we should show the warning.
    elif updated_seconds_ago > WARNING_THRESHOLD and uptime_seconds > UPTIME_GRACE_PERIOD:
        sdlog.warning("The last successful update of the SecureDrop Workstation was completed "
                      "{0:.1f} hours ago, and the system has been up for {1:.1f} hours. "
                      "Showing security warning."
                      .format(updated_hours_ago, uptime_hours))
        show_update_notification()


def show_update_notification():
    app = QtGui.QApplication([])  # noqa: F841

    QMessageBox.warning(None,
                        'Security check recommended',
                        'The workstation has been running continuously for a long time. '
                        'We recommend that you launch or restart the SecureDrop app to '
                        'check for security updates.',
                        QMessageBox.Ok,
                        QMessageBox.Ok)


def get_gui_user():
    group = "qubes"
    cmd = ['getent', 'group', group]
    try:
        group = subprocess.check_output(cmd).decode("utf-8").rstrip("\n")
    except subprocess.CalledProcessError as e:
        if e.returncode == 2:
            sdlog.error("Unable to identify Qubes GUI user; no system user with "
                        "membership in group {}."
                        .format(group))
            sys.exit(1)
        else:
            raise

    # Format group_name:password:GID:user1,user2 (see `man group`)
    group_fields = group.split(":")
    users = group_fields[3].split(",")
    if len(users) > 1:
        sdlog.warning("More than one GUI user detected. SecureDrop Workstation "
                      "is meant to have a single GUI user. Defaulting to first "
                      "GUI user in list.")
    return users[0]


if __name__ == "__main__":
    main()
